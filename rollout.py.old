import jax
from jax import numpy as jnp
from jax.tree_util import register_pytree_node

from einops import rearrange

from physics import step


class RolloutResult:
    def __init__(
        self,
        states,
        actions,
        encoded_states,
        encoded_actions,
        next_states,
        next_state_jacobians,
        reconstructed_states,
        reconstructed_actions,
    ) -> None:
        self.states = states
        self.actions = actions
        self.encoded_states = encoded_states
        self.encoded_actions = encoded_actions
        self.next_states = next_states
        self.next_state_jacobians = next_state_jacobians
        self.reconstructed_states = reconstructed_states
        self.reconstructed_actions = reconstructed_actions

    @staticmethod
    def collect(
        state_encoder_params,
        action_encoder_params,
        forward_params,
        state_decoder_params,
        action_decoder_params,
        q_0,
        qd_0,
        mass_config,
        shape_config,
        policy,
        dt,
        substep,
        steps,
        state_encoder_state,
        action_encoder_state,
        forward_state,
        state_decoder_state,
        action_decoder_state,
    ):
        # Collect a rollout of physics data
        def scanf(carry, i):
            q, qd, action = carry

            new_action = policy(
                q,
                qd,
                state_encoder_state,
                action_encoder_state,
                forward_state,
                state_decoder_state,
                action_decoder_state,
            )

            jax.lax.cond(
                i % substep == 0,
                lambda: new_action,
                lambda: action,
            )
            q, qd = step(q, qd, mass_config, shape_config, action, dt / substep)
            return (q, qd, action), (q, qd, action)

        _, scan_result_sub = jax.lax.scan(
            scanf, (q_0, qd_0), jnp.arange(steps * substep)
        )

        # Now transform that data through our models
        scan_result = scan_result_sub[::substep]

        qs, qds, actions = scan_result[:, 0], scan_result[:, 1], scan_result[:, 2]

        states = rearrange([qs, qds], "i t d -> t (i d)")

        encoded_states = state_encoder_state.apply_fn(
            {"params": state_encoder_params}, states
        )
        encoded_actions = action_encoder_state.apply_fn(
            {"params": action_encoder_params}, actions
        )

        next_states = forward_state.apply_fn(
            {"params": forward_params},
            encoded_states,
            encoded_actions,
        )

        next_state_jacs = jax.jacfwd(forward_state.apply_fn, argnums=(1, 2))(
            forward_params,
            encoded_states,
            encoded_actions,
        )

        reconstructed_states = state_decoder_state.apply_fn(
            {"params": state_decoder_params}, encoded_states
        )
        reconstructed_actions = action_decoder_state.apply_fn(
            {"params": action_decoder_params}, encoded_actions
        )

        return RolloutResult(
            qs,
            policy,
            encoded_states,
            encoded_actions,
            next_states,
            next_state_jacs,
            reconstructed_states,
            reconstructed_actions,
        )


def flatten_rollout_result(rollout_result):
    return [
        rollout_result.states,
        rollout_result.actions,
        rollout_result.encoded_states,
        rollout_result.encoded_actions,
        rollout_result.next_states,
        rollout_result.next_state_jacobians,
        rollout_result.reconstructed_states,
        rollout_result.reconstructed_actions,
    ], None


def unflatten_rollout_result(aux, flat_rollout_result):
    return RolloutResult(*flat_rollout_result)


register_pytree_node(
    RolloutResult,
    flatten_rollout_result,
    unflatten_rollout_result,
)
